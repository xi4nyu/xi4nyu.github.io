---
title: Go 语言：函数
tags:
  - go
categories: go
date: 2023-04-25 20:31:00
---


### 函数

```go
// 声明
func funcName(param1 type1, param2 type2, ...interface{}) (ret1 type1, ret2 type2) {
    // 函数体
}

// 变长参数形参与实参转换
func myAppend(sl []int, elems ...int) []int {
    fmt.Println("%T\n", elems)
    if (len(elems) == 0) {
        fmt.Println("elems is empty")
        return sl
    }

    sl = append(sl, elems...)
    return sl
}

func main() {
    sl := []int{1, 2, 3}
    sl = myAppend(sl)
    fmt.Println(sl)  // [1, 2, 3]  通过切片实现
    sl = myAppend(sl, 4, 5, 6)
    fmt.Println(sl)  // [1, 2, 3, 4, 5, 6] 通过切片实现
}

// 函数返回值
func foo()
func foo() error
func foo() (int, string, error)
```

函数作为“一等公民”的使用。

1. 函数类型的使用
```go
func greeting(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Welcome, Gopher!\n")
}

func main() {
    http.ListenAndServe(":8080", http.HandlerFunc(greeting))
}

// $GOROOT/src/net/http/server.go
type HandlerFunc func(ResponseWriter, *Request)
// ServeHTTP 实现了Handler接口
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r)
}
```
2. 利用闭包简化函数调用
```go
func times1(x, y int) int {
    return x * y
}

// 可以使用闭包简化函数调用
func times2(x int) func(int) int {
    return func(y int) int {
        return x * y
    }
}

func main() {
    timeTwo := times2(2)
    fmt.Println(timeTwo(3))  // 6
    timeThree := times2(3)
    fmt.Println(timeThree(3))  // 9
}
```

### 错误处理

`Go`继承了`C`语言的错误处理方式。
1. 函数返回值
```go

// error 是一个接口类型，通常在函数返回值的末尾位置声明。
func foo() (int, error) {
    return 0, errors.New("error")
}
func main() {
    ret, err := foo()
}
```

在一些场景下，错误处理者需要从错误中提取出更多的信息。这个时候我们可以自定义错误类型来满足这一需求。比如：标准库中`net`包就定义了一种携带额外上下文的错误类型。
```go
// $GOROOT/src/net/net.go
type OpError struct {
    Op string
    Net string
    Source Addr
    Addr Addr
    Err error
}

// $GOROOT/src/net/http/server.go
func isCommonNetReadError(err error) bool {
    if err == io.EOF {
        return true
    }
    if neterr, ok := err.(net.Error); ok && neterr.Timeout() {
        return true
    }
    if oe, ok := err.(*net.OpError); ok && oe.Op == "read" {
        return true
    }

    return false
}

```

`Go`中使用`error`的几点好处：
1. 统一了错误类型
2. 错误是值
3. 易扩展，支持自定错误上下文

错误处理的几种策略:
1. 透明错误处理策略，就是根据函数/方法返回的`error`类型变量中携带的错误信息做相应的处理。
```go
err := doSomething()

if err != nil {
    // 不关心err变量底层错误携带的具体上下文信息
    // 简单处理错误逻辑并返回
    return err
}
```
2. “哨兵”错误处理策略，我们可以通过`errors.Is`方法来判断错误是否为“哨兵”错误。“哨兵”错误值变量以 ErrXXX 格式命名。和透明错误策略相比，“哨兵”策略让错误处理方在有检视错误值的需求时候，可以“有的放矢”。

```go
var ErrSentinel = errors.New("the underlying sentinel error")

func main() {
    err1 := fmt.Errorf("wrap sentinel: %w", ErrSentinel)
    err2 := fmt.Errorf("wrap err1 %w", err1)

    fmt.Println(err2 == ErrSentinel)  // false

    if errors.Is(err2, ErrSentinel) {
        fmt.Println("err2 is ErrSentinel")
        return
    }

    fmt.Println("err2 is not ErrSentinel")
}
```

3. 错误值类型检查策略，我们可以通过`errors.As`方法来判断错误是否为特定类型的错误。
```go
type MyError struct {
    e string
}

func (e *MyError) Error() string {
    return e.e
}

func main() {
    var err = &MyError{"MyError error demo"}
    err1 := fmt.Errorf("wrap err: %w", err)
    err2 := fmt.Errorf("wrap err1: %w", err1)
    var e *MyError
    if errors.As(err2, &e) {
        fmt.Println("MyError is on the chain of err2")
        fmt.Println(e == err)
        return
    }
    fmt.Println("MyError is not on the chain of err2")
}
```

4. 错误行为特征检查策略，将某个包中的错误类型归类，统一提取出一些公共的错误行为特征，并将这些错误行为特征放入一个公开的接口类型中。

```go
type OpError struct {
    // Err is the error that occurred during the operation
    Err error
}

type temporary interface {
    Temporary() bool
}

func (e *OpError) Temporary() bool {
    if ne, ok := e.Err.(*os.SyscallError); ok {
        t, ok := ne.Err.(temporary)
        return ok && t.Temporary()
    }

    t, ok := e.Err.(temporary)
    return ok && t.Temporary()
}
```


